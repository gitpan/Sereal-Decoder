.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Sereal::Decoder 3"
.TH Sereal::Decoder 3 "2014-04-13" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
Sereal::Decoder \- Fast, compact, powerful binary deserialization
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Sereal::Decoder
\&    qw(decode_sereal sereal_decode_with_object scalar_looks_like_sereal);
.Ve
.PP
.Vb 1
\&  my $decoder = Sereal::Decoder->new({...options...});
.Ve
.PP
.Vb 2
\&  my $structure;
\&  $decoder->decode($blob, $structure); # deserializes into $structure
.Ve
.PP
.Vb 2
\&  # or if you don't have references to the top level structure, this works, too:
\&  $structure = $decoder->decode($blob);
.Ve
.PP
.Vb 3
\&  # alternatively functional interface: (See Sereal::Performance)
\&  sereal_decode_with_object($decoder, $blob, $structure);
\&  $structure = sereal_decode_with_object($decoder, $blob);
.Ve
.PP
.Vb 3
\&  # much slower functional interface with no persistent objects:
\&  decode_sereal($blob, {... options ...}, $structure);
\&  $structure = decode_sereal($blob, {... options ...});
.Ve
.PP
.Vb 4
\&  # Not a full validation, but just a quick check for a reasonable header:
\&  my $is_likely_sereal = scalar_looks_like_sereal($some_string);
\&  # or:
\&  $is_likely_sereal = $decoder->looks_like_sereal($some_string);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This library implements a deserializer for an efficient, compact\-output,
and feature-rich binary protocol called \fISereal\fR.
Its sister module Sereal::Encoder implements an encoder for this format.
The two are released separately to allow for independent and safer upgrading.
.PP
The Sereal protocol versions that are compatible with this decoder implementation
are currently protocol versions 1 and 2. As it stands, it will refuse to attempt to
decode future versions of the protocol, but if necessary there is likely
going to be an option to decode the parts of the input that are compatible
with version 2 of the protocol. The protocol was designed to allow for this.
.PP
The protocol specification and many other bits of documentation
can be found in the github repository. Right now, the specification is at
<https://github.com/Sereal/Sereal/blob/master/sereal_spec.pod>,
there is a discussion of the design objectives in
<https://github.com/Sereal/Sereal/blob/master/README.pod>, and the output
of our benchmarks can be seen at
<https://github.com/Sereal/Sereal/wiki/Sereal\-Comparison\-Graphs>.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.Sh "new"
.IX Subsection "new"
Constructor. Optionally takes a hash reference as first parameter. This hash
reference may contain any number of options that influence the behaviour of the
encoder.
.PP
Currently, the following options are recognized, none of them are on
by default.
.PP
\fIrefuse_snappy\fR
.IX Subsection "refuse_snappy"
.PP
If set, the decoder will refuse Snappy-compressed input data. This can be
desirable for robustness. See the section \f(CW\*(C`ROBUSTNESS\*(C'\fR below.
.PP
\fIrefuse_objects\fR
.IX Subsection "refuse_objects"
.PP
If set, the decoder will refuse deserializing any objects in the input stream and
instead throw and exception. Defaults to off. See the section \f(CW\*(C`ROBUSTNESS\*(C'\fR below.
.PP
\fIno_bless_objects\fR
.IX Subsection "no_bless_objects"
.PP
If set, the decoder will deserialize any objects in the input stream but without
blessing them. Defaults to off. See the section \f(CW\*(C`ROBUSTNESS\*(C'\fR below.
.PP
\fIvalidate_utf8\fR
.IX Subsection "validate_utf8"
.PP
If set, the decoder will refuse invalid \s-1UTF\-8\s0 byte sequences. This is off
by default, but it's strongly encouraged to be turned on if you're dealing
with any data that has been encoded by an external source (e.g. http cookies).
.PP
\fImax_recursion_depth\fR
.IX Subsection "max_recursion_depth"
.PP
\&\f(CW\*(C`Sereal::Decoder\*(C'\fR is recursive. If you pass it a Sereal document that is deeply
nested, it will eventually exhaust the C stack. Therefore, there is a limit on
the depth of recursion that is accepted. It defaults to 10000 nested calls. You
may choose to override this value with the \f(CW\*(C`max_recursion_depth\*(C'\fR option.
Beware that setting it too high can cause hard crashes.
.PP
Do note that the setting is somewhat approximate. Setting it to 10000 may break at
somewhere between 9997 and 10003 nested structures depending on their types.
.PP
\fImax_num_hash_entries\fR
.IX Subsection "max_num_hash_entries"
.PP
If set to a non-zero value (default: 0), then \f(CW\*(C`Sereal::Decoder\*(C'\fR will refuse
to deserialize any hash/dictionary (or hash-based object) with more than
that number of entries. This is to be able to respond quickly to any future
hash-collision attacks on Perl's hash function. Chances are, you don't want
or need this. For a gentle introduction to the topic from the cryptographic
point of view, see <http://en.wikipedia.org/wiki/Collision_attack>.
.PP
\fIincremental\fR
.IX Subsection "incremental"
.PP
If set to a non-zero value (default: 0), then \f(CW\*(C`Sereal::Decoder\*(C'\fR will
destructively parse Sereal documents out of a variable. Every time a Sereal
document is successfully parsed it is removed from the front of the string
it is parsed from.
.PP
This means you can do this:
.PP
.Vb 3
\&    while (length $buffer) {
\&        my $data= decode_sereal($buffer,{incremental=>1});
\&    }
.Ve
.SH "INSTANCE METHODS"
.IX Header "INSTANCE METHODS"
.Sh "decode"
.IX Subsection "decode"
Given a byte string of Sereal data, the \f(CW\*(C`decode\*(C'\fR call deserializes that data
structure. The result can be obtained in one of two ways: \f(CW\*(C`decode\*(C'\fR accepts
a second parameter, which is a scalar to write the result to, \s-1AND\s0 \f(CW\*(C`decode\*(C'\fR
will return the resulting data structure.
.PP
The two are subtly different in case of data structures that contain
references to the root element. In that case, the return value will be
a (non\-recursive) copy of the reference. The pass-in style is more correct.
In other words,
.PP
.Vb 3
\&  $decoder->decode($sereal_string, my $out);
\&  # is almost the same but safer than:
\&  my $out = $decoder->decode($sereal_string);
.Ve
.PP
This is an unfortunate side-effect of perls standard copy semantics of
assignment. Possibly one day we will have an alternative to this.
.Sh "decode_with_offset"
.IX Subsection "decode_with_offset"
Same as the \f(CW\*(C`decode\*(C'\fR method, except as second parameter, you must
pass an integer offset into the input string, at which the decoding is
to start. The optional \*(L"pass\-in\*(R" style scalar (see \f(CW\*(C`decode\*(C'\fR above)
is relegated to being the third parameter.
.Sh "bytes_consumed"
.IX Subsection "bytes_consumed"
After using the \f(CW\*(C`decode\*(C'\fR method, \f(CW\*(C`bytes_consumed\*(C'\fR can return the
number of bytes of the input string that were actually consumed by
the decoder. That is, if you append random garbage to a valid
Sereal document, \f(CW\*(C`decode\*(C'\fR will happily decode the data and ignore the
garbage. If that is an error in your use case, you can use \f(CW\*(C`bytes_consumed\*(C'\fR
to catch it.
.PP
.Vb 4
\&  my $out = $decoder->decode($sereal_string);
\&  if (length($sereal_string) != $decoder->bytes_consumed) {
\&    die "Not all input data was consumed!";
\&  }
.Ve
.PP
Chances are that if you do this, you're violating \s-1UNIX\s0 philosophy
in \*(L"be strict in what you emit but lenient in what you accept\*(R".
.PP
You can also use this to deserialize a list of Sereal documents that
is concatenated into the same string (code not very robust...):
.PP
.Vb 10
\&  my @out;
\&  my $pos = 0;
\&  eval {
\&    while (1) {
\&      push @out, $decoder->decode_with_offset($sereal_string, $pos);
\&      $pos += $decoder->bytes_consumed;
\&      last if $pos >= length($sereal_string)
\&           or not $decoder->bytes_consumed;
\&    }
\&  };
.Ve
.Sh "looks_like_sereal"
.IX Subsection "looks_like_sereal"
Given a string (or undef), checks whether it looks like it starts
with a valid Sereal packet. This is not a full-blown validation.
Instead, this just checks the magic string and some header properties
to provide a quick and efficient way to distinguish multiple well-formed
serialization methods instead of really making sure it's valid Sereal.
For reference, sereal's magic string is a four byte string \f(CW\*(C`=srl\*(C'\fR.
.SH "EXPORTABLE FUNCTIONS"
.IX Header "EXPORTABLE FUNCTIONS"
.Sh "sereal_decode_with_object"
.IX Subsection "sereal_decode_with_object"
The functional interface that is equivalent to using \f(CW\*(C`decode\*(C'\fR.  Takes a
decoder object reference as first argument, followed by a byte string
to deserialize.  Optionally takes a third parameter, which is the output
scalar to write to. See the documentation for \f(CW\*(C`decode\*(C'\fR above for details.
.PP
This functional interface is marginally faster than the \s-1OO\s0 interface
since it avoids method resolution overhead and, on sufficiently modern
Perl versions, can usually avoid subroutine call overhead. See
Sereal::Performance for a discussion on how to tune Sereal for maximum
performance if you need to.
.Sh "decode_sereal"
.IX Subsection "decode_sereal"
The functional interface that is equivalent to using \f(CW\*(C`new\*(C'\fR and \f(CW\*(C`decode\*(C'\fR.
Expects a byte string to deserialize as first argument, optionally followed
by a hash reference of options (see documentation for \f(CW\*(C`new()\*(C'\fR). Finally,
\&\f(CW\*(C`decode_sereal\*(C'\fR supports a third parameter, which is the output scalar
to write to. See the documentation for \f(CW\*(C`decode\*(C'\fR above for details.
.PP
This functional interface is significantly slower than the \s-1OO\s0 interface since
it cannot reuse the decoder object.
.Sh "scalar_looks_like_sereal"
.IX Subsection "scalar_looks_like_sereal"
The functional interface that is equivalent to using \f(CW\*(C`looks_like_sereal\*(C'\fR.
.SH "ROBUSTNESS"
.IX Header "ROBUSTNESS"
This implementation of a Sereal decoder tries to be as robust to invalid
input data as reasonably possible. This means that it should never
(though read on) segfault. It may, however, cause a large malloc
to fail. Generally speaking, invalid data should cause a Perl-trappable
exception. The one exception is that for Snappy-compressed Sereal documents,
the Snappy library may cause segmentation faults (invalid reads or writes).
This should only be a problem if you do not checksum your data (internal
checksum support is a To\-Do) or if you accept data from potentially
malicious sources.
.PP
It requires a lot of run-time boundary checks to prevent decoder
segmentation faults on invalid data. We implemented them in the
lightest way possible. Adding robustness against running out of memory
would cause an very significant run-time overhead. In most cases of
random garbage (with valid header no less) when a \fImalloc()\fR fails due
to invalid data, the problem was caused by a very large array or
string length. This kind of very large malloc can then fail, being
trappable from Perl. Only when packet causes many repeated allocations
do you risk causing a hard \s-1OOM\s0 error from the kernel that cannot be
trapped because Perl may require some small allocations to succeed
before the now-invalid memory is released. It is at least not entirely
trivial to craft a Sereal document that causes this behaviour.
.PP
Finally, deserializing proper objects is potentially a problem because
classes can define a destructor. Thus, the data fed to the decoder can
cause the (deferred) execution of any destructor in your application.
That's why the \f(CW\*(C`refuse_objects\*(C'\fR option exists and what the \f(CW\*(C`no_bless_objects\*(C'\fR
can be used for as well. Later on, we may or may not provide a facility to
whitelist classes. Furthermore, if the encoder emitted any objects using
\&\f(CW\*(C`FREEZE\*(C'\fR callbacks, the \f(CW\*(C`THAW\*(C'\fR class method may be invoked on the
respective classes. If you can't trust the source of your Sereal documents,
you may want to use the \f(CW\*(C`refuse_objects\*(C'\fR option. For more details on
the \f(CW\*(C`FREEZE/THAW\*(C'\fR mechanism, please refer to Sereal::Encoder.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
Please refer to the Sereal::Performance document
that has more detailed information about Sereal performance and
tuning thereof.
.SH "THREAD-SAFETY"
.IX Header "THREAD-SAFETY"
\&\f(CW\*(C`Sereal::Decoder\*(C'\fR is thread-safe on Perl's 5.8.7 and higher. This means
\&\*(L"thread\-safe\*(R" in the sense that if you create a new thread, all
\&\f(CW\*(C`Sereal::Decoder\*(C'\fR objects will become a reference to undef in the new
thread. This might change in a future release to become a full clone
of the decoder object.
.SH "BUGS, CONTACT AND SUPPORT"
.IX Header "BUGS, CONTACT AND SUPPORT"
For reporting bugs, please use the github bug tracker at
<http://github.com/Sereal/Sereal/issues>.
.PP
For support and discussion of Sereal, there are two Google Groups:
.PP
Announcements around Sereal (extremely low volume):
<https://groups.google.com/forum/?fromgroups#!forum/sereal\-announce>
.PP
Sereal development list:
<https://groups.google.com/forum/?fromgroups#!forum/sereal\-dev>
.SH "AUTHORS AND CONTRIBUTORS"
.IX Header "AUTHORS AND CONTRIBUTORS"
Yves Orton <demerphq@gmail.com>
.PP
Damian Gryski
.PP
Steffen Mueller <smueller@cpan.org>
.PP
Rafaël Garcia-Suarez
.PP
Ævar Arnfjörð Bjarmason <avar@cpan.org>
.PP
Tim Bunce
.PP
Daniel Dragan <bulkdd@cpan.org> (Windows support and bugfixes)
.PP
Zefram
.PP
Borislav Nikolov
.PP
Some inspiration and code was taken from Marc Lehmann's
excellent \s-1JSON::XS\s0 module due to obvious overlap in
problem domain.
.SH "ACKNOWLEDGMENT"
.IX Header "ACKNOWLEDGMENT"
This module was originally developed for Booking.com.
With approval from Booking.com, this module was generalized
and published on \s-1CPAN\s0, for which the authors would like to express
their gratitude.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2012, 2013, 2014 by Steffen Mueller
Copyright (C) 2012, 2013, 2014 by Yves Orton
.PP
The license for the code in this distribution is the following,
with the exceptions listed below:
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
Except portions taken from Marc Lehmann's code for the \s-1JSON::XS\s0
module, which is licensed under the same terms as this module.
(Many thanks to Marc for inspiration, and code.)
.PP
Also except the code for Snappy compression library, whose license
is reproduced below and which, to the best of our knowledge,
is compatible with this module's license. The license for the
enclosed Snappy code is:
.PP
.Vb 2
\&  Copyright 2011, Google Inc.
\&  All rights reserved.
.Ve
.PP
.Vb 3
\&  Redistribution and use in source and binary forms, with or without
\&  modification, are permitted provided that the following conditions are
\&  met:
.Ve
.PP
.Vb 9
\&    * Redistributions of source code must retain the above copyright
\&  notice, this list of conditions and the following disclaimer.
\&    * Redistributions in binary form must reproduce the above
\&  copyright notice, this list of conditions and the following disclaimer
\&  in the documentation and/or other materials provided with the
\&  distribution.
\&    * Neither the name of Google Inc. nor the names of its
\&  contributors may be used to endorse or promote products derived from
\&  this software without specific prior written permission.
.Ve
.PP
.Vb 11
\&  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\&  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
\&  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
\&  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
\&  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
\&  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
\&  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
\&  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
\&  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
\&  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
\&  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.Ve
